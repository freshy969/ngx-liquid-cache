# ngx-liquid-cache

> LiquidCache: a powerful, automatic and optimized Angular2/6+ cache system that fits everywhere!

## Getting started

Install the library in your Angular project:
```
npm install ngx-liquid-cache
```

## Fast Setup (zero configuration)

1. Import `NgxLiquidCacheModule` in `app.module.ts`:

```typescript
//...
import { NgxLiquidCacheModule } from 'ngx-liquid-cache';

@NgModule({
  //...
  imports: [
    //...
    NgxLiquidCacheModule.forRoot()
  ],
  //...
})
export class AppModule { }

```
2. Use the `@LiquidCache` decorator in any method that return a result. Don't worry about the type of the returned value or about making adaptations to your code: LiquidCache is perfectly integrable with every existing method withouth change anything.

```typescript
import { LiquidCache } from 'ngx-liquid-cache';

// Observable Example
export class ApiService {

  constructor(
      private http: HttpClient,
  ) { }

  @LiquidCache('users')
  getUsers() {
      console.log('getUsers Call');
      return this.http.get('users');
  }
}

// Sync Example
export class UtilsService {

  @LiquidCache('calcResult')
  longCalc() {
      console.log('longCalc Call');
      let a  = 0;
      for (let i = 0; i < 100000000; i++) {
          a += i;
      }
      return a;
  }
}
```

3. Call your methods and see the magic: original methods will be executed only the first time you invoke them. After the first call you will receive the cached result, speeding up your application. 

```typescript
// Automatic Example (cache by decorators)
export class ExampleComponent {

  constructor(
      private apiService: ApiService,
      private utilsService: UtilsService,
  ) { }

  testObservable() {
      this.apiService.getUsers.subscribe(result => console.log('First call', result));
      this.apiService.getUsers.subscribe(result => console.log('Second call', result));
      
      // Console output:
      // getUsers Call
      // First call (...)
      // Second call (...)
  }
  
  testSync() {
      console.log('First call', this.utilsService.longCalc());
      console.log('Second call', this.utilsService.longCalc());
      
      // Console output:
      // longCalc Call
      // First call (...)
      // Second call (...)
  }
}
```

4. You can also use `LiquidCacheService` to interact directly with your cache:

```typescript
import { LiquidCacheService } from 'ngx-liquid-cache';

// Manual Example
export class ExampleComponent {

  constructor(
      private cache: LiquidCacheService,
  ) { }

  testManual() {
      this.cache.set('testKey', 10);
      console.log('Data from cache', this.cache.get('testKey'));
      this.cache.remove('testKey'); // Remove element from cache
      
      // You can of course interact also with cache data generated by decorators
      console.log('Data from decorator', this.cache.get('users')); // 'users' is the key used in the apiService's decorator
  }
}
```

## Configuration

The configuration for LiquidCache is divided in three parts: Global, Decorator and Object.

Here's the full configuration parameters list:

Parameter			| Type				| Default		| Description
---						| ---					| ---				| ---
`duration`		| *number*		| `null`		| The duration for cached elements (in seconds). A trigger will remove expired objects from the cache system.


### Global configuration

You can pass a `LiquidCacheConfig` object to the `NgxLiquidCacheModule.forRoot()` method to specify the global configuration for your cache system.

```typescript
//...
import { NgxLiquidCacheModule, LiquidCacheConfig } from 'ngx-liquid-cache';

const liquidCacheConfig: LiquidCacheConfig = {
  //...
};

@NgModule({
  //...
  imports: [
    //...
    NgxLiquidCacheModule.forRoot(liquidCacheConfig)
  ],
  //...
})
export class AppModule { }

```

### Decorator configuration

The `@LiquidCache` decorator accepts two arguments: `key` (`string`, required) and `configuration` (`LiquidCacheConfig`, optional).

1. The `key` argument could be static (ex. `'myKey'`) or "dynamic", using special placeholders (`{placeholder name}`) that will collect data from the original method arguments (ex. `mySingleKey{id}`):

```typescript
export class ApiService {
  
  //...
  
  // Supposing to invoke getSingleUser(1), the result 
  // will be stored in the cache system with key 'user1'
  @LiquidCache('user{id}')
  getSingleUser(id) {
      return this.http.get('users/' + id);
  }
}
```

2. The `configuration` argument accepts a `LiquidCacheConfig` object, so you can pass a specific configuration for this single decorator:

```typescript
export class ApiService {
  
  // Uses a specific configuration
  @LiquidCache('user{id}', { duration: 60 })
  getSingleUser(id) { ... }
  
  // Will use the global configuration
  @LiquidCache('users')
  getUsers() { ... }
}
```

### Object configuration

You can set a specific configuration for every cache key that you will create:

```typescript
import { LiquidCacheService, LiquidCacheConfig } from 'ngx-liquid-cache';

export class TestComponent {

  constructor(
      private cache: LiquidCacheService,
  ) { }

  test() {
      const specificConf: LiquidCacheConfig = { duration: 60 };
      this.cache.set('myKey', 'cached value', specificConf);
  }
}
```


## Example

Open `example/index.html` in your browser to see jQuery MultiSelector Plugin in action or click [here](http://htmlpreview.github.io/?https://github.com/luckyseven/jquery-multiselector/blob/master/example/index.html).


**Have you used this plugin in your project?**

Say hello with a [tweet](https://twitter.com/luckysevenrox)!

## Alternatives

**Need a non-jquery version?**

I'm already working on it, but feel free to contact me and ask for improvement!


## History

Check [Releases](https://github.com/luckyseven/jquery-multiselector/releases) for detailed changelog.


## License

> MIT License - Copyright (c) 2017 Alberto Fecchi

Full license [here](LICENSE)